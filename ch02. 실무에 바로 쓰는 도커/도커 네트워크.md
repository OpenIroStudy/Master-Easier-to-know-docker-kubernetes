### 도커 네트워크

### 브릿지 모드
브릿지 모드는 도커 네트워크의 default 설정이며 가장 많이 사용하는 네트워크이다. <br>
![image](https://user-images.githubusercontent.com/43237961/174493209-b299c6fa-a7b9-4a39-b013-3a90ad6bc9e6.png) <br><br><br><br> 
<b> 3:docker0은 도커가 점유하고 있는 네트워크 인터페이스이다. </b> <br><br>
도커를 설치하면 기본적으로 docker0이라는 네트워크 인터페이스가 생긴다. <br>
docker0은 컨테이너들이 통신하기 위한 가상 Linux Bridge이다. <br>
Linux bridge는 bridge 네트워크 안엣 컨테이너들끼리 독립적으로 통신하도록 해 주고, <br>
외부 호스트 서버와도 통신할 수 있도록 하는 네트워크 기술을 말한다. <br>
<br> 
![image](https://user-images.githubusercontent.com/43237961/174493626-ecc96244-4bfc-4fb4-a15e-9a31a4244668.png)  <br>
87pg 참조 <br>
호스트 서버와 컨테이너들이 동일하게 네트워크 통신을 할 수 있도록 Linux bridge가 지원한다. <br>
호스트 서버 안데 컨테이너들이 윙치해 있지만 bridge를 통해 독립적인 네트워크 형성 <br>

```linux
 docker network insepct bridge //도커 bridge에 대한 정보를 확인할 수 있다. 
```

* 실습
Nginx, Mysql 오피셜 이미지에 ifconfig 명령어가 추가된 이미지 만들기

```
FROM nginx:latest
RUN apt-get update
RUN apt-get install -y net-tools
RUN apt-get install -y iputils-ping

FROM mysql:5.7.8
RUN apt-get update
RUN apt-get install -y net-tools
RUN apt-get install -y iputils-ping

docker build -t mysql-custom .
docker build -t mysql-custom .

docker run --name db -e MYSQL_ROOT_PASSWORD=1234 -p 3306:3306 -d mysql-custom
```
![image](https://user-images.githubusercontent.com/43237961/174494268-bcff1372-d293-48f6-b8a6-db117748608c.png)   
<br>
컨테이너 ifconfig 명령을 실행할 수 있도록 패키지 매니저를 이용해 설치했다. <br>
172.17.0.3,가 IP로 할당됐다. 네트워크 환경이 호스트 서버와 동일하기 때문에 호스트 서버에서 컨테이너의 IP를 통해 통신이 가능해야 한다. <br>

![image](https://user-images.githubusercontent.com/43237961/174494426-3163fad8-0826-4637-8864-99449b9a6d92.png)
<br><br> 
IP를 사용해 통신하는 것을 볼 수 있다. <br> 
![image](https://user-images.githubusercontent.com/43237961/174509381-e4dfc96e-b399-4092-806d-a5124df00453.png)  <br>
![image](https://user-images.githubusercontent.com/43237961/174509603-cbf71414-646e-4136-97f6-088cd74c4811.png) 
<br> <br>
컨테이너 간의 통신 <br>
172.17.0.4를 할당 받은 nginx 컨테이너에서 172.17.0.3 ip를 할당받은 db 컨테이너와 IP를 이용하여 통신이 가능하다는 것이 확인되었다. <br><br>
<b>근데 이게 뭔 말인지 모르겟음 </b>
<br><br> 

```
docker run --name nginx1 --link nginx:nginx -d nginx-custom
```
- 컨테이너를 생성할 때 -link 옵션을 주면 nginx라는 컨테이너와 이름을 통해 통신할 수 있게 된다. <br> 
유동아이피로 인한 불편을 덜어둔다. <br>
![image](https://user-images.githubusercontent.com/43237961/174511081-cf198fa4-05c7-48c9-80ce-f592c0b37583.png)
 <br><br>
 link 옵션을 사용하게 되면 컨테이너의 hosts 파일에 해당 DNS를 추가하게 된다. <br>
 

- 기본 bridge가 아닌 도커 사용자가 직접 정의한 bridge를 만드러서 컨테이너를 생성할 때 네트워크로 사용하는 것이다. 
![image](https://user-images.githubusercontent.com/43237961/174511372-92264278-3e0b-428a-9905-c05768e0537a.png)  
<br><br> 

![image](https://user-images.githubusercontent.com/43237961/174511587-a34d21d1-4bff-4c7f-ab15-1b8cc45ccb61.png)  <br><br>
nginx2 컨테이너에서 nginx3 컨테이너로 통신이 가능한 모습이라는데 아직까지는 뭔소린지 모르겠다. <br>  




<br><br><br>

### host 모드
네트워크를 host모드로 실행시키면 도커가 독자적인 네트워크를 갖지 않고 host와 네트워크를 같이 사용하게 된다. <br>
host모드로 컨테이너를 실행하기 위해서는 컨테이너를 실행할 때 옵션을 추가해야 한다. <br> 

```
docker run --name nginx4 --net=host -d nginx-custom
```
host모드로 컨테이너를 실행하기 위해서는 컨테이너를 실행할 때 옵션을 추가해야 한다. <br>
![image](https://user-images.githubusercontent.com/43237961/174513017-b18717f9-85b4-46fd-9b25-fa75560fbf4d.png)
<br>
![image](https://user-images.githubusercontent.com/43237961/174513106-c7da8eab-2e15-44b3-bab6-a5ba4d9072ae.png)
<br> 

80 번 포트가 이미 사용 중이라서 실행되지 않았다. <br>
-net=host 옵션을 사용하면 -p 옵션은 사용하지 못한다. 그래서 도커 이미지에 명세된 기본 포트밖에 사용하지 못하게 된다. <br>
host 모드로 똑같은 도커 이미지 베이스의 컨테이너를 실행한다면 실패하게 된다. <br>
다른 프로세스에서 이미 포트를 사용하고 있으면 컨테이너가 실행되지 않는다. <br>
![image](https://user-images.githubusercontent.com/43237961/174514781-b068ee06-4ad1-4583-b05b-47eb80a5af29.png)
<br><br> 기존 80포트를 죽이고 다시 명령 실행 <br>
host모드는 호스트와 동일한 네트워크 인터페이스를 사용하기 때문에 bridge 모드에서는 각각의 컨테이너 IP가 발급되었으나, <br>
host모드에서는 IP가 할당되지 않고 해당 호스트와 똑같은 인터페이스를 사용하게 된다. <br>
<br>

### container 모드
container모드는 해당 컨테이너의 네트워크 구성을 참조하는 컨테이너와 동일하게 구성해 주는 것이다. <br>
참조하는 기존 컨테이너의 네트워크를 공유한다. <br>
